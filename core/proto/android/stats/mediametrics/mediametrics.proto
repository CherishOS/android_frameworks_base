/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto2";

package android.stats.mediametrics;

/**
 * Track how we arbitrate between microphone/input requests.
 * Logged from
 *   frameworks/av/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiopolicy.cpp
 * Next Tag: 10
 */
message AudioPolicyData {
    optional int32 status = 1;
    optional string request_source = 2;
    optional string request_package = 3;
    optional int32 request_session = 4;
    optional string request_device = 5;
    optional string active_source = 6;
    optional string active_package = 7;
    optional int32 active_session = 8;
    optional string active_device = 9;
}

/**
 * Track properties of audio recording
 * Logged from
 *   frameworks/av/media/libaudioclient/AudioRecord.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiorecord.cpp
 * Next Tag: 16
 */
message AudioRecordData {
    optional string encoding = 1;
    optional string source = 2;
    optional int32 latency = 3;
    optional int32 samplerate = 4;
    optional int32 channels = 5;
    optional int64 created_millis = 6;
    optional int64 duration_millis = 7;
    optional int32 count = 8;
    optional int32 error_code = 9;
    optional string error_function = 10;
    optional int32 port_id = 11;
    optional int32 frame_count = 12;
    optional string attributes = 13;
    optional int64 channel_mask = 14;
    optional int64 start_count = 15;

}

/**
 * Track audio thread performance data
 * Logged from
 *   frameworks/av/media/libnblog/ReportPerformance.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiothread.cpp
 * Next Tag: 28
 */
message AudioThreadData {
    optional string type = 1;
    optional int32 framecount = 2;
    optional int32 samplerate = 3;
    optional string work_millis_hist = 4;
    optional string latency_millis_hist = 5;
    optional string warmup_millis_hist = 6;
    optional int64 underruns = 7;
    optional int64 overruns = 8;
    optional int64 active_millis = 9;
    optional int64 duration_millis = 10;

    optional int32 id = 11;
    optional int32 port_id = 12;
    optional int32 sample_rate = 13;
    optional int64 channel_mask = 14;
    optional string encoding = 15;
    optional int32 frame_count = 16;
    optional string output_device = 17;
    optional string input_device = 18;
    optional double io_jitter_mean_millis = 19;
    optional double io_jitter_stddev_millis = 20;
    optional double process_time_mean_millis = 21;
    optional double process_time_stddev_millis = 22;
    optional double timestamp_jitter_mean_millis = 23;
    optional double timestamp_jitter_stddev_millis = 24;
    optional double latency_mean_millis = 25;
    optional double latency_stddev_millis = 26;

}

/**
 * Track audio track playback data
 * Logged from
 *   frameworks/av/media/libaudioclient/AudioTrack.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiotrack.cpp
 * Next Tag: 12
 */
message AudioTrackData {
    optional string stream_type = 1;
    optional string content_type = 2;
    optional string track_usage = 3;
    optional int32 sample_rate = 4;
    optional int64 channel_mask = 5;

    optional int32 underrun_frames = 6;
    optional int32 startup_glitch = 7;

    optional int32 port_id = 8;
    optional string encoding = 9;
    optional int32 frame_count = 10;
    optional string attributes = 11;


}

/**
 * Track Media Codec usage
 * Logged from:
 *   frameworks/av/media/libstagefright/MediaCodec.cpp
 *   frameworks/av/services/mediaanalytics/statsd_codec.cpp
 * Next Tag: 26
 */
message CodecData {
    optional string codec = 1;
    optional string mime = 2;
    optional string mode = 3;
    optional int32 encoder = 4;
    optional int32 secure = 5;
    optional int32 width = 6;
    optional int32 height = 7;
    optional int32 rotation = 8;
    optional int32 crypto = 9;
    optional int32 profile = 10;
    optional int32 level = 11;
    optional int32 max_width = 12;
    optional int32 max_height = 13;
    optional int32 error_code = 14;
    optional string error_state = 15;
    optional int64 latency_max = 16;
    optional int64 latency_min = 17;
    optional int64 latency_avg = 18;
    optional int64 latency_count = 19;
    optional int64 latency_unknown = 20;
    optional int32 queue_input_buffer_error = 21;
    optional int32 queue_secure_input_buffer_error = 22;
    optional string bitrate_mode = 23;
    optional int32 bitrate = 24;
    optional int64 lifetime_millis = 25;
}

/**
 * Track Media Extractor (pulling video/audio streams out of containers) usage
 * Logged from:
 *   frameworks/av/media/libstagefright/RemoteMediaExtractor.cpp
 *   frameworks/av/services/mediaanalytics/statsd_extractor.cpp
 * Next Tag: 4
 */
message ExtractorData {
    optional string format = 1;
    optional string mime = 2;
    optional int32 tracks = 3;
}

/**
 * Track Media Player usage
 * this handles both nuplayer and nuplayer2
 * Logged from:
 *   frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
 *   frameworks/av/media/libmediaplayer2/nuplayer2/NuPlayer2Driver.cpp
 *   frameworks/av/services/mediaanalytics/statsd_nuplayer.cpp
 * Next Tag: 21
 */
message NuPlayerData {
    optional string whichPlayer = 1;

    optional string video_mime = 2;
    optional string video_codec = 3;
    optional int32 width = 4;
    optional int32 height = 5;
    optional int64 frames = 6;
    optional int64 frames_dropped = 7;
    optional double framerate = 8;
    optional string audio_mime = 9;
    optional string audio_codec = 10;
    optional int64 duration_millis = 11;
    optional int64 playing_millis = 12;
    optional int32 error = 13;
    optional int32 error_code = 14;
    optional string error_state = 15;
    optional string data_source_type = 16;
    optional int64 rebuffering_millis = 17;
    optional int32 rebuffers = 18;
    optional int32 rebuffer_at_exit = 19;
    optional int64 frames_dropped_startup = 20;
}

/**
 * Track information about recordings (e.g. camcorder)
 * Logged from
 *   frameworks/av/media/libmediaplayerservice/StagefrightRecorder.cpp
 *   frameworks/av/services/mediaanalytics/if_statsd.cpp
 * Next Tag: 22
 */
message RecorderData {
    optional string audio_mime = 1;
    optional string video_mime = 2;
    optional int32 video_profile = 3;
    optional int32 video_level = 4;
    optional int32 width = 5;
    optional int32 height = 6;
    optional int32 rotation = 7;
    optional int32 framerate = 8;
    optional int32 capture_fps = 9;
    optional double capture_fps_enable = 10;
    optional int64 duration_millis = 11;
    optional int64 paused_millis = 12;
    optional int32 paused_count = 13;
    optional int32 audio_bitrate = 14;
    optional int32 audio_channels = 15;
    optional int32 audio_samplerate = 16;
    optional int32 movie_timescale = 17;
    optional int32 audio_timescale = 18;
    optional int32 video_timescale = 19;
    optional int32 video_bitrate = 20;
    optional int32 iframe_interval = 21;
}

enum StreamType {
    STREAM_TYPE_UNKNOWN = 0;
    STREAM_TYPE_OTHER = 1;
    STREAM_TYPE_PROGRESSIVE = 2;
    STREAM_TYPE_DASH = 3;
    STREAM_TYPE_HLS = 4;
    STREAM_TYPE_SS = 5;
}

enum DrmType {
    DRM_TYPE_NONE = 0;
    DRM_TYPE_OTHER = 1;
    DRM_TYPE_PLAY_READY = 2;
    DRM_TYPE_WV_L1 = 3;
    DRM_TYPE_WV_L3 = 4;
}

enum PlaybackType {
    PLAYBACK_TYPE_VOD = 0;
    PLAYBACK_TYPE_LIVE = 1;
    PLAYBACK_TYPE_OTHER = 2;
}

enum ContentType {
    CONTENT_TYPE_MAIN = 0;
    CONTENT_TYPE_AD = 1;
    CONTENT_TYPE_OTHER = 2;
}

enum StreamSourceType {
    STREAM_SOURCE_UNKNOWN = 0;
    STREAM_SOURCE_NETWORK = 1;
    STREAM_SOURCE_DEVICE = 2;
    STREAM_SOURCE_MIXED = 3;
}
enum NetworkType {
    NETWORK_TYPE_NONE = 0;
    NETWORK_TYPE_OTHER = 1;
    NETWORK_TYPE_WIFI = 2;
    NETWORK_TYPE_ETHERNET = 3;
    NETWORK_TYPE_2G = 4;
    NETWORK_TYPE_3G = 5;
    NETWORK_TYPE_4G = 6;
    NETWORK_TYPE_5G_NSA = 7;
    NETWORK_TYPE_5G_SA = 8;
}

enum PlaybackState {
    // Playback has not started (initial state)
    NOT_STARTED = 0;
    // Playback is buffering in the background for initial playback start
    JOINING_BACKGROUND = 1;
    // Playback is buffering in the foreground for initial playback start
    JOINING_FOREGROUND = 2;
    // Playback is actively playing
    PLAYING = 3;
    // Playback is paused but ready to play
    PAUSED = 4;
    // Playback is handling a seek
    SEEKING = 5;
    // Playback is buffering to resume active playback
    BUFFERING = 6;
    // Playback is buffering while paused
    PAUSED_BUFFERING = 7;
    // Playback is suppressed (e.g. due to audio focus loss)
    SUPPRESSED = 8;
    // Playback is suppressed (e.g. due to audio focus loss) while buffering to resume a
    // playback
    SUPPRESSED_BUFFERING = 9;
    // Playback has reached the end of the media
    ENDED = 10;
    // Playback is stopped and can be restarted
    STOPPED = 11;
    // Playback is stopped due a fatal error and can be retried
    FAILED = 12;
    // Playback is interrupted by an ad
    INTERRUPTED_BY_AD = 13;
    // Playback is abandoned before reaching the end of the media
    ABANDONED = 14;
}

enum PlaybackErrorCode {
    ERROR_CODE_UNKNOWN = 0;
    ERROR_CODE_OTHER = 1;
    ERROR_CODE_RUNTIME = 2;
}

enum TrackType {
    AUDIO = 0;
    VIDEO = 1;
    TEXT = 2;
}
enum TrackState {
    OFF = 0;
    ON = 1;
}
enum TrackChangeReason {
    REASON_UNKNOWN = 0;
    REASON_OTHER = 1;
    REASON_INITIAL = 2;
    REASON_MANUAL = 3;
    REASON_ADAPTIVE = 4;
}
