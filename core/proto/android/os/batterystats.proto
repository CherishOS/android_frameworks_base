/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto2";
option java_multiple_files = true;

package android.os;

import "frameworks/base/core/proto/android/telephony/signalstrength.proto";

message BatteryStatsProto {
  optional int32 report_version = 1;
  optional int64 parcel_version = 2;
  optional string start_platform_version = 3;
  optional string end_platform_version = 4;
  optional BatteryHistoryProto history = 5;
  repeated UidProto uids = 6;
  optional SystemProto system = 7;
}

message BatteryHistoryProto {
}

message ControllerActivityProto {
  // Time (milliseconds) spent in the idle state.
  optional int64 idle_duration_ms = 1;
  // Time (milliseconds) spent in the receive state.
  optional int64 rx_duration_ms = 2;
  // Total power (mAh) consumed by the controller in all states. The value may
  // always be 0 if the device doesn't support power calculations.
  optional int64 power_mah = 3;

  // Represents a transmit level, where each level may draw a different amount
  // of power. The levels themselves are controller-specific (and may possibly
  // be device specific...yet to be confirmed).
  message TxLevel {
    // Transmit level. Higher levels draw more power.
    optional int32 level = 1;
    // Time spent in this specific transmit level state.
    optional int64 duration_ms = 2;
  }
  repeated TxLevel tx = 4;
}

message SystemProto {
  message Battery {
    // Wall clock time when the data collection started.
    // In case of device time manually reset by users:
    //   start_clock_time_ms keeps the same value in the current collection
    //   period and changes for later collection periods.
    optional int64 start_clock_time_ms = 1;
    // #times the device has been started since start_clock_time_millis.
    optional int64 start_count = 2;
    // Total realtime duration (= SINCE_UNPLUGGED battery_realtime_millis.)
    optional int64 total_realtime_ms = 3;
    optional int64 total_uptime_ms = 4;
    // Realtime duration on battery.
    optional int64 battery_realtime_ms = 5;
    // Uptime duration (i.e., not suspend).
    // Uptime is anytime the CPUs were on. The radio and Wifi chip
    // can be running while the CPUs are off.
    optional int64 battery_uptime_ms = 6;
    // Total realtime duration measured with screen off or dozing.
    optional int64 screen_off_realtime_ms = 7;
    // Total uptime duration measured with screen off or dozing.
    optional int64 screen_off_uptime_ms = 8;
    // Total time the screen was dozing while the device was running on battery.
    // For historical reasons, screen_doze_duration_msec is a subset of
    // screen_off_realtime_msec.
    optional int64 screen_doze_duration_ms = 9;
    // The estimated real battery capacity, which may be less than the declared
    // battery capacity (for example, because of battery aging). This field is
    // less reliable than min(max)_learned_battery_capacity_uah, use those two
    // fields whenever possible.
    optional int64 estimated_battery_capacity_mah = 10;
    // The minimum learned battery capacity in uAh.
    optional int64 min_learned_battery_capacity_uah = 11;
    // The maximum learned battery capacity in uAh.
    optional int64 max_learned_battery_capacity_uah = 12;
  };
  optional Battery battery = 1;

  message BatteryDischarge {
    // Discharged battery percentage points since the stats were last reset
    // after charging (lower bound approximation).
    optional int32 lower_bound_since_charge = 1;
    // Upper bound approximation.
    optional int32 upper_bound_since_charge = 2;
    // Discharged points while screen is on.
    optional int32 screen_on_since_charge = 3;
    // Discharged points while screen is off.
    optional int32 screen_off_since_charge = 4;
    // Discharged points while screen was dozing. For historical reasons,
    // screen_doze_since_charge is a subset of screen_off_since_charge.
    optional int32 screen_doze_since_charge = 5;
    // Total amount of battery discharged in mAh. This will only be non-zero for
    // devices that report battery discharge via a coulomb counter.
    optional int64 total_mah = 6;
    // Total amount of battery discharged while the screen was off in mAh.
    // This will only be non-zero for devices that report battery discharge
    // via a coulomb counter.
    optional int64 total_mah_screen_off = 7;
    // Total amount of battery discharged while the screen was dozing in mAh.
    // This will only be non-zero for devices that report battery discharge
    // via a coulomb counter. For historical reasons, total_mah_screen_doze is
    // a subset of total_mah_screen_off.
    optional int64 total_mah_screen_doze = 8;
  };
  optional BatteryDischarge battery_discharge = 2;

  oneof time_remaining {
    // Approximation for how much time remains until the battery is fully
    // charged. The device will print -1 if there wasn't enough data to
    // calculate an estimate, or if the battery is currently discharging.
    int64 charge_time_remaining_ms = 3;
    // Approximation for how much time remains until the battery is fully
    // discharged. The device will print -1 if there wasn't enough data to
    // calculate an estimate, or if the battery is currently charging.
    int64 discharge_time_remaining_ms = 4;
  }

  // BatteryLevelStep tracks data for which conditions were continuously held for
  // the entire duration. Field for which the conditions were not consistent
  // for the entire duration should be marked MIXED.
  message BatteryLevelStep {
    // How long the battery was at the current level.
    optional int64 duration_ms = 1;
    // Battery level
    optional int32 level = 2;

    // State of the display. A special enum is used rather than
    // DisplayProto.State because a MIXED value needs to be in the enum, and
    // batterystats doesn't care about all of the different display states.
    enum DisplayState {
      DS_MIXED = 0;
      DS_ON = 1;
      DS_OFF = 2;
      DS_DOZE = 3;
      DS_DOZE_SUSPEND = 4;
      // Any display state error that comes through should be sent to hackbod@.
      DS_ERROR = 5;
    }
    // The state of the display for the entire battery level step. MIXED is used
    // if there were multiple states for this step.
    optional DisplayState display_state = 3;

    // Indicates status in power save mode.
    enum PowerSaveMode {
      PSM_MIXED = 0;
      PSM_ON = 1;
      PSM_OFF = 2;
    }
    // Battery Saver mode for the entire battery level step. MIXED is used
    // if there were multiple states for this step.
    optional PowerSaveMode power_save_mode = 4;

    // Indicates status in idle mode.
    enum IdleMode {
      IM_MIXED = 0;
      IM_ON = 2;
      IM_OFF = 3;
    }
    // Doze mode for the entire battery level step. MIXED is used if there were
    // multiple states for this step.
    optional IdleMode idle_mode = 5;
  };
  // Battery level steps when the device was charging.
  repeated BatteryLevelStep charge_step = 5;
  // Battery level steps when the device was discharging.
  repeated BatteryLevelStep discharge_step = 6;

  // All CPU frequencies of the device.
  repeated int64 cpu_frequency = 7;

  message DataConnection {
    enum Name {
      NONE = 0;
      GPRS = 1;
      EDGE = 2;
      UMTS = 3;
      CDMA = 4;
      EVDO_0 = 5;
      EVDO_A = 6;
      ONE_X_RTT = 7; // 1xRTT.
      HSDPA = 8;
      HSUPA = 9;
      HSPA = 10;
      IDEN = 11;
      EVDO_B = 12;
      LTE = 13;
      EHRPD = 14;
      HSPAP = 15;
      OTHER = 16;
    };
    optional Name name = 1;
    optional TimerProto total = 2;
  };
  repeated DataConnection data_connection = 8;

  optional ControllerActivityProto global_bluetooth_controller = 9;
  optional ControllerActivityProto global_modem_controller = 10;
  optional ControllerActivityProto global_wifi_controller = 11;

  message GlobalNetwork {
    // Total Bytes received on mobile connections.
    optional int64 mobile_bytes_rx = 1;
    // Total Bytes transmitted on mobile connections.
    optional int64 mobile_bytes_tx = 2;
    // Total Bytes received on wifi connections.
    optional int64 wifi_bytes_rx = 3;
    // Total Bytes transmitted on wifi connections.
    optional int64 wifi_bytes_tx = 4;
    // Total Packets received on mobile connections.
    optional int64 mobile_packets_rx = 5;
    // Total Packets transmitted on mobile connections.
    optional int64 mobile_packets_tx = 6;
    // Total Packets received on wifi connections.
    optional int64 wifi_packets_rx = 7;
    // Total Packets transmitted on wifi connections.
    optional int64 wifi_packets_tx = 8;
    // Total Bytes received on bluetooth connections.
    optional int64 bt_bytes_rx = 9;
    // Total Bytes transmitted on bluetooth connections.
    optional int64 bt_bytes_tx = 10;
  };
  optional GlobalNetwork global_network = 12;

  message GlobalWifi {
    // The amount of time that wifi has been on while the device was running on
    // battery.
    optional int64 on_duration_ms = 1;
    // The amount of time that wifi has been on and the driver has been in the
    // running state while the device was running on battery.
    optional int64 running_duration_ms = 2;
  }
  optional GlobalWifi global_wifi = 13;

  // Kernel wakelock metrics are only recorded when the device is unplugged
  // *and* the screen is off.
  message KernelWakelock {
    optional string name = 1;
    // Kernel wakelock stats aren't apportioned across all kernel wakelocks (as
    // app wakelocks stats are).
    optional TimerProto total = 2;
    // The kernel doesn't have the data to enable printing out current and max
    // durations.
  };
  repeated KernelWakelock kernel_wakelock = 14;

  message Misc {
    optional int64 screen_on_duration_ms = 1;
    optional int64 phone_on_duration_ms = 2;
    optional int64 full_wakelock_total_duration_ms = 3;
    // The total elapsed time that a partial wakelock was held. This duration
    // does not double count wakelocks held at the same time.
    optional int64 partial_wakelock_total_duration_ms = 4;
    optional int64 mobile_radio_active_duration_ms = 5;
    // The time that is the difference between the mobile radio time we saw
    // based on the elapsed timestamp when going down vs. the given time stamp
    // from the radio.
    optional int64 mobile_radio_active_adjusted_time_ms = 6;
    optional int32 mobile_radio_active_count = 7;
    // The amount of time that the mobile network has been active (in a high
    // power state) but not being able to blame on an app.
    optional int32 mobile_radio_active_unknown_duration_ms = 8;
    // Total amount of time the device was in the interactive state.
    optional int64 interactive_duration_ms = 9;
    optional int64 battery_saver_mode_enabled_duration_ms = 10;
    optional int32 num_connectivity_changes = 11;
    // Amount of time the device was in deep Doze.
    optional int64 deep_doze_enabled_duration_ms = 12;
    // How many times the device went into deep Doze mode.
    optional int32 deep_doze_count = 13;
    // Amount of time the device was idling in deep Doze. Idling time
    // encompasses "doze" time and the maintenance windows that allow apps to
    // operate.
    optional int64 deep_doze_idling_duration_ms = 14;
    // How many times the device idling for deep Doze mode.
    optional int32 deep_doze_idling_count = 15;
    optional int64 longest_deep_doze_duration_ms = 16;
    // Amount of time the device was in Doze Light.
    optional int64 light_doze_enabled_duration_ms = 17;
    // How many times the device went into Doze Light mode.
    optional int32 light_doze_count = 18;
    // Amount of time the device was idling in Doze Light. Idling time
    // encompasses "doze" time and the maintenance windows that allow apps to
    // operate.
    optional int64 light_doze_idling_duration_ms = 19;
    // How many times the device idling for Doze Light mode.
    optional int32 light_doze_idling_count = 20;
    optional int64 longest_light_doze_duration_ms = 21;
  }
  optional Misc misc = 15;

  message PhoneSignalStrength {
    optional android.telephony.SignalStrengthProto.StrengthName name = 1;
    optional TimerProto total = 2;
  };
  repeated PhoneSignalStrength phone_signal_strength = 16;

  message PowerUseItem {
    enum Sipper {
      UNKNOWN_SIPPER = 0;
      IDLE = 1;
      CELL = 2;
      PHONE = 3;
      WIFI = 4;
      BLUETOOTH = 5;
      FLASHLIGHT = 6;
      SCREEN = 7;
      USER = 8;
      UNACCOUNTED = 9;
      OVERCOUNTED = 10;
      CAMERA = 11;
      MEMORY = 12;
    };
    optional Sipper name = 1;
    // UID, only valid for the USER sipper.
    optional int32 uid = 2;
    // Estimated power use in mAh.
    optional double computed_power_mah = 3;
    // Starting in Oreo, Battery Settings has two modes to display the battery
    // info. The first is "app usage list". In this mode, items with should_hide
    // enabled are hidden.
    optional bool should_hide = 4;
    // Smeared power from screen usage. Screen usage power is split and smeared
    // among apps, based on activity time.
    optional double screen_power_mah = 5;
    // Smeared power using proportional method. Power usage from hidden sippers
    // is smeared to all apps proportionally (except for screen usage).
    optional double proportional_smear_mah = 6;
  };
  repeated PowerUseItem power_use_item = 17;

  message PowerUseSummary {
    optional double battery_capacity_mah = 1;
    optional double computed_power_mah = 2;
    // Lower bound of actual power drained.
    optional double min_drained_power_mah = 3;
    // Upper bound of actual power drained.
    optional double max_drained_power_mah = 4;
  };
  optional PowerUseSummary power_use_summary = 18;

  message ResourcePowerManager {
    optional string name = 1;
    optional TimerProto total = 2;
    optional TimerProto screen_off = 3;
  }
  optional ResourcePowerManager resource_power_manager = 19;

  message ScreenBrightness {
    enum Name {
      DARK = 0; // Not screen-off.
      DIM = 1;
      MEDIUM = 2;
      LIGHT = 3;
      BRIGHT = 4;
    };
    optional Name name = 1;
    optional TimerProto total = 2;
  };
  repeated ScreenBrightness screen_brightness = 20;

  // Duration and number of times trying to acquire a signal
  optional TimerProto signal_scanning = 21;

  message WakeupReason {
    optional string name = 1;
    optional TimerProto total = 2;
  };
  repeated WakeupReason wakeup_reason = 22;

  message WifiSignalStrength {
    enum Name {
      NONE = 0;
      POOR = 1;
      MODERATE = 2;
      GOOD = 3;
      GREAT = 4;
    };
    optional Name name = 1;
    optional TimerProto total = 2;
  };
  repeated WifiSignalStrength wifi_signal_strength = 23;

  message WifiState {
    enum Name {
      OFF = 0;
      OFF_SCANNING = 1;
      ON_NO_NETWORKS = 2;
      ON_DISCONNECTED = 3;
      ON_CONNECTED_STA = 4;
      ON_CONNECTED_P2P = 5;
      ON_CONNECTED_STA_P2P = 6;
      SOFT_AP = 7;
    };
    optional Name name = 1;
    optional TimerProto total = 2;
  };
  repeated WifiState wifi_state = 24;

  message WifiSupplicantState {
    enum Name {
      INVALID = 0;
      DISCONNECTED = 1;
      INTERFACE_DISABLED = 2;
      INACTIVE = 3;
      SCANNING = 4;
      AUTHENTICATING = 5;
      ASSOCIATING = 6;
      ASSOCIATED = 7;
      FOUR_WAY_HANDSHAKE = 8;
      GROUP_HANDSHAKE = 9;
      COMPLETED = 10;
      DORMANT = 11;
      UNINITIALIZED = 12;
    };
    optional Name name = 1;
    optional TimerProto total = 2;
  };
  repeated WifiSupplicantState wifi_supplicant_state = 25;
}

message TimerProto {
  optional int64 duration_ms = 1;
  optional int64 count = 2;
}

message UidProto {
  // Combination of app ID and user ID.
  optional int32 uid = 1;
  repeated string package_names = 2;
}
